import roboticstoolbox as rtb
from spatialmath import SE3
import numpy as np
import matplotlib.pyplot as plt
import ipywidgets as widgets
from IPython.display import display
import swift
# روبوت Panda
robot = rtb.models.Panda()
q_initial = robot.qr.copy()  # وضعية جاهزة

# Swift simulator
env = swift.Swift()
env.launch(realtime=True)
env.add(robot)

def display_robot_info(q):
    T = robot.fkine(q)
    J0 = robot.jacob0(q)
    print("Forward Kinematics (FK) - End Effector Pose:\n", T)
    print("\nJacobian (base frame):\n", J0)
    print("\nCurrent Joint Angles:\n", q)
    return T, J0
def move_to_target(x, y, z):
    T_goal = SE3.Trans(x, y, z) * SE3.OA([0,1,0],[0,0,-1])
    sol = robot.ik_LM(T_goal)
    if sol.success:
        q_sol = sol.q
        print("IK Solution Found:", q_sol)
        robot.q = q_sol
        env.step(0.05)
    else:
        print("IK Solution Not Found")
    return sol

sliders = []
for i in range(robot.n):
    s = widgets.FloatSlider(
        value=q_initial[i]*180/np.pi,
        min=-180, max=180, step=0.5,
        description=f'q{i}', continuous_update=True
    )
    sliders.append(s)

def update_robot(*args):
    q = np.array([s.value*np.pi/180 for s in sliders])
    robot.q = q
    env.step(0.05)
    display_robot_info(q)

for s in sliders:
    s.observe(update_robot, 'value')

display(widgets.VBox(sliders))

x_input = widgets.FloatText(value=0.6, description='X:')
y_input = widgets.FloatText(value=0.0, description='Y:')
z_input = widgets.FloatText(value=0.2, description='Z:')
ik_button = widgets.Button(description="Move to Target (IK)")

def ik_button_clicked(b):
    move_to_target(x_input.value, y_input.value, z_input.value)

ik_button.on_click(ik_button_clicked)
display(widgets.HBox([x_input, y_input, z_input, ik_button]))
# نقاط تخطيط مسار شكل حرف "B"
points = [
    [0.4, 0.0, 0.2],
    [0.4, 0.05, 0.25],
    [0.4, 0.1, 0.2],
    [0.4, 0.05, 0.15],
    [0.4, 0.0, 0.2]
]

trajectory_q = []
for p in points:
    T_goal = SE3.Trans(p[0], p[1], p[2])
    sol = robot.ik_LM(T_goal)
    if sol.success:
        trajectory_q.append(sol.q)
trajectory_q = np.array(trajectory_q)

# رسم المسار في Swift
for q in trajectory_q:
    robot.q = q
    env.step(0.05)

# Optional: plot in matplotlib 3D
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
points_arr = np.array(points)
ax.plot(points_arr[:,0], points_arr[:,1], points_arr[:,2], 'b.-')
ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_zlabel('Z')
plt.show()




